<!doctype html><html lang=en-us><head><meta charset=utf-8><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><!--[if IEMobile]><meta http-equiv=cleartype content="on"><![endif]--><title>B. Roy - ACL Anthology</title><meta name=generator content="Hugo 0.68.3"><link href=/website/aclicon.ico rel="shortcut icon" type=image/x-icon><link rel=stylesheet href=/website/css/main.min.8976777c0832d068a49d330764e507857027f1efa3b8501cf349b0e2db7410fc.css media=screen><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.7.2/css/all.css integrity=sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr crossorigin=anonymous><link rel=stylesheet href=/website/css/academicons.min.css></head><body><nav class="navbar navbar-expand-sm navbar-light bg-light bg-gradient-light shadow-sm py-0 mb-3 mb-md-4 mb-xl-5"><div id=navbar-container class=container><a class=navbar-brand href=/website/><img src=/website/images/acl-logo.svg width=56 alt="ACL Logo">
<span class="d-none d-md-inline pl-md-2">ACL Anthology</span></a>
<button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=/website/faq/>FAQ<span class=sr-only>(current)</span></a></li><li class=nav-item><a class=nav-link href=/website/info/corrections/>Corrections<span class=sr-only>(current)</span></a></li><li class=nav-item><a class=nav-link href=/website/info/contrib/>Submissions<span class=sr-only>(current)</span></a></li></ul><form class="form-inline my-2 my-lg-0" action=/website/search/? method=get><input id=acl-search-box class="form-control mr-sm-2" name=q type=search placeholder=Search... aria-label=Search>
<button class="btn btn-outline-primary" type=submit><i class="fas fa-search"></i></button></form></div></div></nav><div id=main-container class=container><section id=main><h2 id=title><span class=font-weight-normal>B.</span> <span class=font-weight-bold>Roy</span></h2><hr><div class=row><div class=col-lg-9><h4>2022</h4><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2022.GWF-1.6.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G22-1006.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib
</a><a class="badge badge-info align-middle mr-1" href=#abstract-G22-1006 data-toggle=collapse aria-expanded=false aria-controls=abstract-G22-1006 title="Show Abstract">abs</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G22-1006/>Facilitating Asynchronous Collaboration in Scientific Workflow Composition Using Provenance</a></strong><br><a href=/website/people/M/Mostafa-AbediniAla/>Mostafa AbediniAla</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a><br><a href=/website/volumes/G22-1/ class=text-muted>Global Water Futures 2022</a></span></p><div class="card bg-light mb-2 mb-lg-3 collapse abstract-collapse" id=abstract-G22-1006><div class="card-body p-3 small">Advances in scientific domains are led to an increase in the complexity of the experiments. To address this growing complexity, scientists from different domains require to work collaboratively. Scientific Workflow Management Systems (SWfMSs) are popular tools for data-intensive experiments. To the best of our knowledge, very few of the existing SWfMSs support collaboration, and it is not efficient in many cases. Researchers share a single version of the workflow in existing collaborative data analysis systems, which increases the chance of interference as the number of collaborators grows. Moreover, for effective collaboration, contributors require a clear view of the project's status, the information that existing SWfMSs do not provide. Another significant problem is most scientists are not capable of adding collaborative tools to existing SWfMSs, and they need software engineers to take on this responsibility. Even for software engineers such tasks could be challenging and time consuming. In this paper, we attempted to address this crucial issue in scientific workflow composition and doing so in a collaborative setting. Hence, we propose a tool to facilitate collaborative workflow composition. This tool provides branching and versioning, which are standard version control system features to allow multiple researchers to contribute to the project asynchronously. We also suggest some visualizations and a variety of reports to increase group awareness and help the scientists to realize the project's status and issues. As a proof of concept, we developed an API to capture the provenance data and provide collaborative tools. This API is developed as an example for software engineers to help them understand how to integrate collaborative tools into any SWfMS. We collect provenance information during workflow composition and then employ it to track workflow versions using the proposed collaborative tool. Prior to implementing the visualizations, we surveyed to discover how much the proposed visualizations could contribute to group awareness. Moreover, in the survey we investigated to what extent the proposed version control system could help address shortcomings in collaborative experiments. The survey participants provided us with valuable feedback. In future, we will use the survey responses to enhance the proposed version control system and visualizations.</div></div><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2022.GWF-1.7.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G22-1007.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib
</a><a class="badge badge-info align-middle mr-1" href=#abstract-G22-1007 data-toggle=collapse aria-expanded=false aria-controls=abstract-G22-1007 title="Show Abstract">abs</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G22-1007/>Supporting program comprehension by generating abstract code summary tree</a></strong><br><a href=/website/people/A/Avijit-Bhattacharjee/>Avijit Bhattacharjee</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a>
|
<a href=/website/people/K/Kevin-A-Schneider/>Kevin A. Schneider</a><br><a href=/website/volumes/G22-1/ class=text-muted>Global Water Futures 2022</a></span></p><div class="card bg-light mb-2 mb-lg-3 collapse abstract-collapse" id=abstract-G22-1007><div class="card-body p-3 small">Reading through code, finding relevant methods, classes and files takes a significant portion of software development time. Having good tool support for this code browsing activity can reduce human effort and increase overall developer productivity. To help with program comprehension activities, building an abstract code summary of a software system from its call graph is an active research area. A call graph is a visual representation of the caller-callee relationships between different methods of a software system. Call graphs can be difficult to comprehend for a large code-base. Previous work by Gharibi et al. on abstract code summarizing suggested using the Agglomerative Hierarchical Clustering (AHC) tree for understanding the codebase. Each node in the tree is associated with the top five method names. When we replicated the previous approach, we observed that the number of nodes in the AHC tree is burdensome for developers to explore. We also noticed only five method names for each node is not sufficient to comprehend an abstract node. We propose a technique to transform the AHC tree using cluster flattening for natural grouping and reduced nodes. We also generate a natural text summary for each abstract node derived from method comments. In order to evaluate our proposed approach, we collected developers’ opinions about the abstract code summary tree based on their codebase. The evaluation results confirm that our approach can not only help developers get an overview of their codebases but also could assist them in doing specific software maintenance tasks.</div></div><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2022.GWF-1.8.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G22-1008.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib
</a><a class="badge badge-info align-middle mr-1" href=#abstract-G22-1008 data-toggle=collapse aria-expanded=false aria-controls=abstract-G22-1008 title="Show Abstract">abs</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G22-1008/>Supporting Readability by Comprehending the Hierarchical Abstraction of a Software Project</a></strong><br><a href=/website/people/A/Avijit-Bhattacharjee/>Avijit Bhattacharjee</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a>
|
<a href=/website/people/K/Kevin-A-Schneider/>Kevin A. Schneider</a><br><a href=/website/volumes/G22-1/ class=text-muted>Global Water Futures 2022</a></span></p><div class="card bg-light mb-2 mb-lg-3 collapse abstract-collapse" id=abstract-G22-1008><div class="card-body p-3 small">Exploring the source code of a software system is a prevailing task that is frequently done by contributors to a system. Practitioners often use call graphs to aid in understanding the source code of an inadequately documented software system. Call graphs, when visualized, show caller and callee relationships between functions. A static call graph provides an overall structure of a software system and dynamic call graphs generated from dynamic execution logs can be used to trace program behaviour for a particular scenario. Unfortunately a call graph of an entire system can be very complicated and hard to understand. Hierarchically abstracting a call graph can be used to summarize an entire system’s structure and more easily comprehending function calls. In this work, we mine concepts from source code entities (functions) to generate a concept cluster tree with improved naming of cluster nodes to complement existing studies and facilitate more effective program comprehension for developers. We apply three different information retrieval techniques (TFIDF, LDA, and LSI) on function names and function name variants to label the nodes of a concept cluster tree generated by clustering execution paths. From our experiment in comparing automatic labelling with manual labeling by participants for 12 use cases, we found that among the techniques on average, TFIDF performs better with 64% matching. LDA and LSI had 37% and 23% matching respectively. In addition, using the words in function name variants performed at least 5% better in participant ratings for all three techniques on average for the use cases.</div></div><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2022.GWF-1.9.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G22-1009.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib
</a><a class="badge badge-info align-middle mr-1" href=#abstract-G22-1009 data-toggle=collapse aria-expanded=false aria-controls=abstract-G22-1009 title="Show Abstract">abs</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G22-1009/>Feature Transformation for Improved Software Bug Detection Models</a></strong><br><a href=/website/people/S/Shamse-Tasnim-Cynthia/>Shamse Tasnim Cynthia</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a>
|
<a href=/website/people/D/Debajyoti-Mondal/>Debajyoti Mondal</a><br><a href=/website/volumes/G22-1/ class=text-muted>Global Water Futures 2022</a></span></p><div class="card bg-light mb-2 mb-lg-3 collapse abstract-collapse" id=abstract-G22-1009><div class="card-body p-3 small">Testing software is considered to be one of the most crucial phases in software development life cycle. Software bug fixing requires a significant amount of time and effort. A rich body of recent research explored ways to predict bugs in software artifacts using machine learning based techniques. For a reliable and trustworthy prediction, it is crucial to also consider the explainability aspects of such machine learning models. In this paper, we show how the feature transformation techniques can significantly improve the prediction accuracy and build confidence in building bug prediction models. We propose a novel approach for improved bug prediction that first extracts the features, then finds a weighted transformation of these features using a genetic algorithm that best separates bugs from non-bugs when plotted in a low-dimensional space, and finally, trains the machine learning model using the transformed dataset. In our experiment with real-life bug datasets, the random forest and k-nearest neighbor classifier models that leveraged feature transformation showed 4.25% improvement in recall values on an average of over 8 software systems when compared to the models built on original data.</div></div><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2022.GWF-1.10.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G22-1010.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib
</a><a class="badge badge-info align-middle mr-1" href=#abstract-G22-1010 data-toggle=collapse aria-expanded=false aria-controls=abstract-G22-1010 title="Show Abstract">abs</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G22-1010/>Mining Software Information Sites to Recommend Cross-Language Analogical Libraries</a></strong><br><a href=/website/people/K/Kawser-Wazed-Nafi/>Kawser Wazed Nafi</a>
|
<a href=/website/people/M/M-Asaduzzaman/>M. Asaduzzaman</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a>
|
<a href=/website/people/C/C-Roy/>C. Roy</a>
|
<a href=/website/people/K/Kevin-A-Schneider/>Kevin A. Schneider</a><br><a href=/website/volumes/G22-1/ class=text-muted>Global Water Futures 2022</a></span></p><div class="card bg-light mb-2 mb-lg-3 collapse abstract-collapse" id=abstract-G22-1010><div class="card-body p-3 small">Software development is largely dependent on libraries to reuse existing functionalities instead of reinventing the wheel. Software developers often need to find analogical libraries (libraries similar to ones they are already familiar with) as an analogical library may offer improved or additional features. Developers also need to search for analogical libraries across programming languages when developing applications in different languages or for different platforms. However, manually searching for analogical libraries is a time-consuming and difficult task. This paper presents a technique, called XLibRec, that recommends analogical libraries across different programming languages. XLibRec collects Stack Overflow question titles containing library names, library usage information from Stack Overflow posts, and library descriptions from a third party website, Libraries.io. We generate word-vectors for each information and calculate a weight-based cosine similarity score from them to recommend analogical libraries. We performed an extensive evaluation using a large number of analogical libraries across four different programming languages. Results from our evaluation show that the proposed technique can recommend cross-language analogical libraries with great accuracy. The precision for the Top-3 recommendations ranges from 62-81% and has achieved 8-45% higher precision than the state-of-the-art technique.</div></div><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2022.GWF-1.11.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G22-1011.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib
</a><a class="badge badge-info align-middle mr-1" href=#abstract-G22-1011 data-toggle=collapse aria-expanded=false aria-controls=abstract-G22-1011 title="Show Abstract">abs</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G22-1011/>Exploring Relevant Artifacts of Release Notes: The Practitioners' Perspective</a></strong><br><a href=/website/people/S/Sristy-Sumana-Nath/>Sristy Sumana Nath</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a><br><a href=/website/volumes/G22-1/ class=text-muted>Global Water Futures 2022</a></span></p><div class="card bg-light mb-2 mb-lg-3 collapse abstract-collapse" id=abstract-G22-1011><div class="card-body p-3 small">A software release note is one of the essential documents in the software development life cycle. The software release contains a set of information, e.g., bug fixes and security fixes. Release notes are used in different phases, e.g., requirement engineering, software testing and release management. Different types of practitioners (e.g., project managers and clients) get benefited from the release notes to understand the overview of the latest release. As a result, several studies have been done about release notes production and usage in practice. However, two significant problems (e.g., duplication and inconsistency in release notes contents) exist in producing well-written & well-structured release notes and organizing appropriate information regarding different targeted users' needs. For that reason, practitioners face difficulties in writing and reading the release notes using existing tools. To mitigate these problems, we execute two different studies in our paper. First, we execute an exploratory study by analyzing 3,347 release notes of 21 GitHub repositories to understand the documented contents of the release notes. As a result, we find relevant key artifacts, e.g., issues (29%), pull-requests (32%), commits (19%), and common vulnerabilities and exposures (CVE) issues (6%) in the release note contents. Second, we conduct a survey study with 32 professionals to understand the key information that is included in release notes regarding users' roles. For example, project managers are more interested in learning about new features than less critical bug fixes. Our study can guide future research directions to help practitioners produce the release notes with relevant content and improve the documentation quality.</div></div><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2022.GWF-1.12.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G22-1012.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib
</a><a class="badge badge-info align-middle mr-1" href=#abstract-G22-1012 data-toggle=collapse aria-expanded=false aria-controls=abstract-G22-1012 title="Show Abstract">abs</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G22-1012/>Commit-Checker: A human-centric approach for adopting bug inducing commit detection using machine learning models</a></strong><br><a href=/website/people/N/Naz-Zarreen-Zarreen-Oishie/>Naz Zarreen Zarreen Oishie</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a><br><a href=/website/volumes/G22-1/ class=text-muted>Global Water Futures 2022</a></span></p><div class="card bg-light mb-2 mb-lg-3 collapse abstract-collapse" id=abstract-G22-1012><div class="card-body p-3 small">Software bug prediction is one of the promising research areas in software engineering. Software developers must allocate a reasonable amount of time and resources to test and debug the developed software extensively to improve software quality. However, it is not always possible to test software thoroughly with limited time and resources to develop high quality software. Sometimes software companies release software products in a hurry to make profit in a competitive environment. As a result the released software might have software defects and can affect the reputation of those software companies. Ideally, any software application that is already in the market should not contain bugs. If it does, depending on its severity, it might cause a great cost. Although a significant amount of work has been done to automate different parts of testing to detect bugs, fixing a bug after it is discovered is still a costly task that developers need to do. Sometimes these bug fixing changes introduce new bugs in the system. Researchers estimated that 80% of the total cost of a software system is spent on fixing bugs [8]. They show that the software faults and failures costs the US economy $59.5 billion a year [9].</div></div><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2022.GWF-1.13.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G22-1013.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib
</a><a class="badge badge-info align-middle mr-1" href=#abstract-G22-1013 data-toggle=collapse aria-expanded=false aria-controls=abstract-G22-1013 title="Show Abstract">abs</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G22-1013/>Towards Automatically Generating Release Notes using Extractive Summarization Technique</a></strong><br><a href=/website/people/S/Sristy-Sumana-Nath/>Sristy Sumana Nath</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a><br><a href=/website/volumes/G22-1/ class=text-muted>Global Water Futures 2022</a></span></p><div class="card bg-light mb-2 mb-lg-3 collapse abstract-collapse" id=abstract-G22-1013><div class="card-body p-3 small">—Release notes are admitted as an essential document by practitioners. They contain the summary of the source code changes for the software releases, such as issue ﬁxes, added new features, and performance improvements. Manually producing release notes is a time-consuming and challenging task. For that reason, sometimes developers neglect to write release notes. For example, we collect data from GitHub with over 1,900 releases, among them 37% of the release notes are empty. We propose an automatic generate release notes approach based on the commit messages and merge pull-request (PR) titles to mitigate this problem. We implement one of the popular extractive text summarization techniques, i.e., the TextRank algorithm. However, accurate keyword extraction is a vital issue in text processing. The keyword matching and topic extraction process of the TextRank algorithm ignores the semantic similarity among texts. To improve the keyword extraction method, we integrate the GloVe word embedding technique with TextRank. We develop a dataset with 1,213 release notes (after null ﬁltering) and evaluate the generated release notes through the ROUGE metric and human evaluation. We also compare the performance of our technique with another popular extractive algorithm, latent semantic analysis (LSA). Our evaluation results show that the improved TextRank method outperforms LSA.</div></div><h4>2021</h4><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2021.GWF-1.16.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G21-1016.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib
</a><a class="badge badge-info align-middle mr-1" href=#abstract-G21-1016 data-toggle=collapse aria-expanded=false aria-controls=abstract-G21-1016 title="Show Abstract">abs</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G21-1016/>A Testing Approach While Re-engineering Legacy Systems: An Industrial Case Study</a></strong><br><a href=/website/people/H/Hamid-Khodabandehloo/>Hamid Khodabandehloo</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a>
|
<a href=/website/people/M/Manishankar-Mondal/>Manishankar Mondal</a>
|
<a href=/website/people/C/C-Roy/>C. Roy</a>
|
<a href=/website/people/K/Kevin-A-Schneider/>Kevin A. Schneider</a><br><a href=/website/volumes/G21-1/ class=text-muted>Global Water Futures 2021</a></span></p><div class="card bg-light mb-2 mb-lg-3 collapse abstract-collapse" id=abstract-G21-1016><div class="card-body p-3 small">Many organizations use legacy systems as these systems contain their valuable business rules. However, these legacy systems answer the past requirements but are difficult to maintain and evolve due to old technology use. In this situation, stockholders decide to renovate the system with a minimum amount of cost and risk. Although the renovation process is a more affordable choice over redevelopment, it comes with its risks such as performance loss and failure to obtain quality goals. A proper test process can minimize risks incorporated with the renovation process. This work introduces a testing model tailored for the migration and re-engineering process and employs test automation, which results in early bug detection. Moreover, the automated tests ensure functional sameness between the old and the new system. This process enhances reliability, accuracy, and speed of testing.</div></div><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2021.GWF-1.18.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G21-1018.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G21-1018/>ArchiNet: A Concept-token based Approach for Determining Architectural Change Categories</a></strong><br><a href=/website/people/A/Amit-Mondal/>Amit Mondal</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a>
|
<a href=/website/people/S/Sristy-Sumana-Nath/>Sristy Sumana Nath</a>
|
<a href=/website/people/K/Kevin-A-Schneider/>Kevin A. Schneider</a><br><a href=/website/volumes/G21-1/ class=text-muted>Global Water Futures 2021</a></span></p><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2021.GWF-1.19.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G21-1019.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib
</a><a class="badge badge-info align-middle mr-1" href=#abstract-G21-1019 data-toggle=collapse aria-expanded=false aria-controls=abstract-G21-1019 title="Show Abstract">abs</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G21-1019/>Semantic Slicing of Architectural Change Commits: Towards Semantic Design Review</a></strong><br><a href=/website/people/A/A-Mondal/>A. Mondal</a>
|
<a href=/website/people/C/C-Roy/>C. Roy</a>
|
<a href=/website/people/K/Kevin-A-Schneider/>Kevin A. Schneider</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a>
|
<a href=/website/people/S/Sristy-Sumana-Nath/>Sristy Sumana Nath</a><br><a href=/website/volumes/G21-1/ class=text-muted>Global Water Futures 2021</a></span></p><div class="card bg-light mb-2 mb-lg-3 collapse abstract-collapse" id=abstract-G21-1019><div class="card-body p-3 small">Software architectural changes involve more than one module or component and are complex to analyze compared to local code changes. Development teams aiming to review architectural aspects (design) of a change commit consider many essential scenarios such as access rules and restrictions on usage of program entities across modules. Moreover, design review is essential when proper architectural formulations are paramount for developing and deploying a system. Untangling architectural changes, recovering semantic design, and producing design notes are the crucial tasks of the design review process. To support these tasks, we construct a lightweight tool [4] that can detect and decompose semantic slices of a commit containing architectural instances. A semantic slice consists of a description of relational information of involved modules, their classes, methods and connected modules in a change instance, which is easy to understand to a reviewer. We extract various directory and naming structures (DANS) properties from the source code for developing our tool. Utilizing the DANS properties, our tool first detects architectural change instances based on our defined metric and then decomposes the slices (based on string processing). Our preliminary investigation with ten open-source projects (developed in Java and Kotlin) reveals that the DANS properties produce highly reliable precision and recall (93-100%) for detecting and generating architectural slices. Our proposed tool will serve as the preliminary approach for the semantic design recovery and design summary generation for the project releases.</div></div><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2021.GWF-1.20.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G21-1020.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G21-1020/>ID-correspondence: a measure for detecting evolutionary coupling</a></strong><br><a href=/website/people/M/Manishankar-Mondal/>Manishankar Mondal</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a>
|
<a href=/website/people/C/C-Roy/>C. Roy</a>
|
<a href=/website/people/K/Kevin-A-Schneider/>Kevin A. Schneider</a><br><a href=/website/volumes/G21-1/ class=text-muted>Global Water Futures 2021</a></span></p><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2021.GWF-1.21.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G21-1021.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib
</a><a class="badge badge-info align-middle mr-1" href=#abstract-G21-1021 data-toggle=collapse aria-expanded=false aria-controls=abstract-G21-1021 title="Show Abstract">abs</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G21-1021/>FLeCCS: A Technique for Suggesting Fragment-Level Similar Co-change Candidates</a></strong><br><a href=/website/people/M/Manishankar-Mondal/>Manishankar Mondal</a>
|
<a href=/website/people/C/C-Roy/>C. Roy</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a>
|
<a href=/website/people/K/Kevin-A-Schneider/>Kevin A. Schneider</a><br><a href=/website/volumes/G21-1/ class=text-muted>Global Water Futures 2021</a></span></p><div class="card bg-light mb-2 mb-lg-3 collapse abstract-collapse" id=abstract-G21-1021><div class="card-body p-3 small">When a programmer changes a particular code fragment, the other similar code fragments in the code-base may also need to be changed together (i.e., co-changed) consistently to ensure that the software system remains consistent. Existing studies and tools apply clone detectors to identify these similar co-change candidates for a target code fragment. However, clone detectors suffer from a confounding configuration choice problem and it affects their accuracy in retrieving co-change candidates.In our research, we propose and empirically evaluate a lightweight co-change suggestion technique that can automatically suggest fragment level similar co-change candidates for a target code fragment using WA-DiSC (Weighted Average Dice–Sørensen Co-efficient) through a context-sensitive mining of the entire code-base. We apply our technique, FLeCCS (Fragment Level Co-change Candidate Suggester), on six subject systems written in three different programming languages (Java, C, and C#) and compare its performance with the existing state-of-the-art techniques. According to our experiment, our technique outperforms not only the existing code clone based techniques but also the association rule mining based techniques in detecting co-change candidates with a significantly higher accuracy (precision and recall). We also find that File Proximity Ranking performs significantly better than Similarity Extent Ranking when ranking the co-change candidates suggested by our proposed technique.</div></div><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2021.GWF-1.22.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G21-1022.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib
</a><a class="badge badge-info align-middle mr-1" href=#abstract-G21-1022 data-toggle=collapse aria-expanded=false aria-controls=abstract-G21-1022 title="Show Abstract">abs</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G21-1022/>Reproducibility Challenges and Their Impacts on Technical Q&A Websites: The Practitioners’ Perspectives</a></strong><br><a href=/website/people/S/Saikat-Mondal/>Saikat Mondal</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a><br><a href=/website/volumes/G21-1/ class=text-muted>Global Water Futures 2021</a></span></p><div class="card bg-light mb-2 mb-lg-3 collapse abstract-collapse" id=abstract-G21-1022><div class="card-body p-3 small">Software developers often submit questions to technical Q&A sites like Stack Overflow (SO) to resolve their code-level problems. Usually, they include example code segments with their questions to explain the programming issues. When users of SO attempt to answer the questions, they prefer to reproduce the issues reported in questions using the given code segments. However, such code segments could not always reproduce the issues due to several unmet challenges (e.g., too short code segment) that might prevent questions from receiving appropriate and prompt solutions. A previous study produced a catalog of potential challenges that hinder the reproducibility of issues reported at SO questions. However, it is unknown how the practitioners (i.e., developers) perceive the challenge catalog. Understanding the developers’ perspective is inevitable to introduce interactive tool support that promotes reproducibility. We thus attempt to understand developers’ perspectives by surveying 53 users of SO. In particular, we attempt to – (1) see developers’ viewpoints on the agreement to those challenges, (2) find the potential impact of those challenges, (3) see how developers address them, and (4) determine and prioritize tool support needs. Survey results show that about 90% of participants agree to the already exposed challenges. However, they report some additional challenges (e.g., error log missing) that might prevent reproducibility. According to the participants, too short code segment and absence of required Class/Interface/Method from code segments severely prevent reproducibility, followed by missing important part of code. To promote reproducibility, participants strongly recommend introducing tool support that interacts with question submitters with suggestions for improving the code segments if the given code segments fail to reproduce the issues.</div></div><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2021.GWF-1.23.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G21-1023.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib
</a><a class="badge badge-info align-middle mr-1" href=#abstract-G21-1023 data-toggle=collapse aria-expanded=false aria-controls=abstract-G21-1023 title="Show Abstract">abs</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G21-1023/>Automatically Generating Release Notes with Content Classification Models</a></strong><br><a href=/website/people/S/Sristy-Sumana-Nath/>Sristy Sumana Nath</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a><br><a href=/website/volumes/G21-1/ class=text-muted>Global Water Futures 2021</a></span></p><div class="card bg-light mb-2 mb-lg-3 collapse abstract-collapse" id=abstract-G21-1023><div class="card-body p-3 small">Release notes are admitted as an essential technical document in software maintenance. They summarize the main changes, e.g. bug fixes and new features, that have happened in the software since the previous release. Manually producing release notes is a time-consuming and challenging task. For that reason, sometimes developers neglect to write release notes. For example, we collect data from GitHub with over 1900 releases, and among them, 37% of the release notes are empty. To mitigate this problem, we propose an automatic release notes generation approach by applying the text summarization techniques, i.e. TextRank. To improve the keyword extraction method of traditional TextRank, we integrate the GloVe word embedding technique with TextRank. After generating release notes automatically, we apply machine learning algorithms to classify the release note contents (or sentences). We classify the contents into six categories, e.g. bug fixes and performance improvements, to represent the release notes better for users. We use the evaluation metric, e.g. ROUGE, to evaluate the automatically generated release notes. We also compare the performance of our technique with two popular extractive algorithms, e.g. Luhn’s and latent semantic analysis (LSA). Our evaluation results show that the improved TextRank method outperforms the two algorithms.</div></div><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2021.GWF-1.25.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G21-1025.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G21-1025/>Large Scale Image Registration Utilizing Data-Tunneling in the MapReduce Cluster</a></strong><br><a href=/website/people/A/Amit-Kumar-Mondal/>Amit Kumar Mondal</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a>
|
<a href=/website/people/C/C-Roy/>C. Roy</a>
|
<a href=/website/people/K/Kevin-A-Schneider/>Kevin A. Schneider</a><br><a href=/website/volumes/G21-1/ class=text-muted>Global Water Futures 2021</a></span></p><h4>2020</h4><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2020.GWF-1.3.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G20-1003.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib
</a><a class="badge badge-info align-middle mr-1" href=#abstract-G20-1003 data-toggle=collapse aria-expanded=false aria-controls=abstract-G20-1003 title="Show Abstract">abs</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G20-1003/>Designing for Recommending Intermediate States in A Scientific Workflow Management System</a></strong><br><a href=/website/people/D/Debasish-Chakroborti/>Debasish Chakroborti</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a>
|
<a href=/website/people/S/Sristy-Sumana-Nath/>Sristy Sumana Nath</a><br><a href=/website/volumes/G20-1/ class=text-muted>Global Water Futures 2020</a></span></p><div class="card bg-light mb-2 mb-lg-3 collapse abstract-collapse" id=abstract-G20-1003><div class="card-body p-3 small">To process a large amount of data sequentially and systematically, proper management of workflow components (i.e., modules, data, configurations, associations among ports and links) in a Scientific Workflow Management System (SWfMS) is inevitable. Managing data with provenance in a SWfMS to support reusability of workflows, modules, and data is not a simple task. Handling such components is even more burdensome for frequently assembled and executed complex workflows for investigating large datasets with different technologies (i.e., various learning algorithms or models). However, a great many studies propose various techniques and technologies for managing and recommending services in a SWfMS, but only a very few studies consider the management of data in a SWfMS for efficient storing and facilitating workflow executions. Furthermore, there is no study to inquire about the effectiveness and efficiency of such data management in a SWfMS from a user perspective. In this paper, we present and evaluate a GUI version of such a novel approach of intermediate data management with two use cases (Plant Phenotyping and Bioinformatics). The technique we call GUI-RISPTS (Recommending Intermediate States from Pipelines Considering Tool-States) can facilitate executions of workflows with processed data (i.e., intermediate outcomes of modules in a workflow) and can thus reduce the computational time of some modules in a SWfMS. We integrated GUI-RISPTS with an existing workflow management system called SciWorCS. In SciWorCS, we present an interface that users use for selecting the recommendation of intermediate states (i.e., modules' outcomes). We investigated GUI-RISPTS's effectiveness from users' perspectives along with measuring its overhead in terms of storage and efficiency in workflow execution.</div></div><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2020.GWF-1.76.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G20-1076.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib
</a><a class="badge badge-info align-middle mr-1" href=#abstract-G20-1076 data-toggle=collapse aria-expanded=false aria-controls=abstract-G20-1076 title="Show Abstract">abs</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G20-1076/>An Exploratory Study to Find Motives Behind Cross-platform Forks from Software Heritage Dataset</a></strong><br><a href=/website/people/A/Avijit-Bhattacharjee/>Avijit Bhattacharjee</a>
|
<a href=/website/people/S/Sristy-Sumana-Nath/>Sristy Sumana Nath</a>
|
<a href=/website/people/S/Shurui-Zhou/>Shurui Zhou</a>
|
<a href=/website/people/D/Debasish-Chakroborti/>Debasish Chakroborti</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a>
|
<a href=/website/people/C/C-Roy/>C. Roy</a>
|
<a href=/website/people/K/Kevin-A-Schneider/>Kevin A. Schneider</a><br><a href=/website/volumes/G20-1/ class=text-muted>Global Water Futures 2020</a></span></p><div class="card bg-light mb-2 mb-lg-3 collapse abstract-collapse" id=abstract-G20-1076><div class="card-body p-3 small">The fork-based development mechanism provides the flexibility and the unified processes for software teams to collaborate easily in a distributed setting without too much coordination overhead. Currently, multiple social coding platforms support fork-based development, such as GitHub, GitLab, and Bitbucket. Although these different platforms virtually share the same features, they have different emphasis. As GitHub is the most popular platform and the corresponding data is publicly available, most of the current studies are focusing on GitHub hosted projects. However, we observed anecdote evidences that people are confused about choosing among these platforms, and some projects are migrating from one platform to another, and the reasons behind these activities remain unknown. With the advances of Software Heritage Graph Dataset (SWHGD), we have the opportunity to investigate the forking activities across platforms. In this paper, we conduct an exploratory study on 10 popular open-source projects to identify cross-platform forks and investigate the motivation behind. Preliminary result shows that cross-platform forks do exist. For the 10 subject systems used in this study, we found 81,357 forks in total among which 179 forks are on GitLab. Based on our qualitative analysis, we found that most of the cross-platform forks that we identified are mirrors of the repositories on another platform, but we still find cases that were created due to preference of using certain functionalities (e.g. Continuous Integration (CI)) supported by different platforms. This study lays the foundation of future research directions, such as understanding the differences between platforms and supporting cross-platform collaboration.</div></div><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2020.GWF-1.116.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G20-1116.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib
</a><a class="badge badge-info align-middle mr-1" href=#abstract-G20-1116 data-toggle=collapse aria-expanded=false aria-controls=abstract-G20-1116 title="Show Abstract">abs</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G20-1116/>VizSciFlow: A Visually Guided Scripting Framework for Supporting Complex Scientific Data Analysis</a></strong><br><a href=/website/people/M/M-M-Hossain/>M. M. Hossain</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a>
|
<a href=/website/people/C/C-Roy/>C. Roy</a>
|
<a href=/website/people/K/Kevin-A-Schneider/>Kevin A. Schneider</a><br><a href=/website/volumes/G20-1/ class=text-muted>Global Water Futures 2020</a></span></p><div class="card bg-light mb-2 mb-lg-3 collapse abstract-collapse" id=abstract-G20-1116><div class="card-body p-3 small">Scientific workflow management systems such as Galaxy, Taverna and Workspace, have been developed to automate scientific workflow management and are increasingly being used to accelerate the specification, execution, visualization, and monitoring of data-intensive tasks. For example, the popular bioinformatics platform Galaxy is installed on over 168 servers around the world and the social networking space myExperiment shares almost 4,000 Galaxy scientific workflows among its 10,665 members. Most of these systems offer graphical interfaces for composing workflows. However, while graphical languages are considered easier to use, graphical workflow models are more difficult to comprehend and maintain as they become larger and more complex. Text-based languages are considered harder to use but have the potential to provide a clean and concise expression of workflow even for large and complex workflows. A recent study showed that some scientists prefer script/text-based environments to perform complex scientific analysis with workflows. Unfortunately, such environments are unable to meet the needs of scientists who prefer graphical workflows. In order to address the needs of both types of scientists and at the same time to have script-based workflow models because of their underlying benefits, we propose a visually guided workflow modeling framework that combines interactive graphical user interface elements in an integrated development environment with the power of a domain-specific language to compose independently developed and loosely coupled services into workflows. Our domain-specific language provides scientists with a clean, concise, and abstract view of workflow to better support workflow modeling. As a proof of concept, we developed VizSciFlow, a generalized scientific workflow management system that can be customized for use in a variety of scientific domains. As a first use case, we configured and customized VizSciFlow for the bioinformatics domain. We conducted three user studies to assess its usability, expressiveness, efficiency, and flexibility. Results are promising, and in particular, our user studies show that VizSciFlow is more desirable for users to use than either Python or Galaxy for solving complex scientific problems.</div></div><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2020.GWF-1.137.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G20-1137.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib
</a><a class="badge badge-info align-middle mr-1" href=#abstract-G20-1137 data-toggle=collapse aria-expanded=false aria-controls=abstract-G20-1137 title="Show Abstract">abs</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G20-1137/>Associating Code Clones with Association Rules for Change Impact Analysis</a></strong><br><a href=/website/people/M/Manishankar-Mondal/>Manishankar Mondal</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a>
|
<a href=/website/people/C/C-Roy/>C. Roy</a>
|
<a href=/website/people/K/Kevin-A-Schneider/>Kevin A. Schneider</a><br><a href=/website/volumes/G20-1/ class=text-muted>Global Water Futures 2020</a></span></p><div class="card bg-light mb-2 mb-lg-3 collapse abstract-collapse" id=abstract-G20-1137><div class="card-body p-3 small">When a programmer makes changes to a target program entity (files, classes, methods), it is important to identify which other entities might also get impacted. These entities constitute the impact set for the target entity. Association rules have been widely used for discovering the impact sets. However, such rules only depend on the previous co-change history of the program entities ignoring the fact that similar entities might often need to be updated together consistently even if they did not co-change before. Considering this fact, we investigate whether cloning relationships among program entities can be associated with association rules to help us better identify the impact sets. In our research, we particularly investigate whether the impact set detection capability of a clone detector can be utilized to enhance the capability of the state-of-the-art association rule mining technique, Tarmaq, in discovering impact sets. We use the well known clone detector called NiCad in our investigation and consider both regular and micro-clones. Our evolutionary analysis on thousands of commit operations of eight diverse subject systems reveals that consideration of code clones can enhance the impact set detection accuracy of Tarmaq with a significantly higher precision and recall. Micro-clones of 3LOC and 4LOC and regular code clones of 5LOC to 20LOC contribute the most towards enhancing the detection accuracy.</div></div><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2020.GWF-1.138.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G20-1138.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib
</a><a class="badge badge-info align-middle mr-1" href=#abstract-G20-1138 data-toggle=collapse aria-expanded=false aria-controls=abstract-G20-1138 title="Show Abstract">abs</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G20-1138/>HistoRank: History-Based Ranking of Co-change Candidates</a></strong><br><a href=/website/people/M/Manishankar-Mondal/>Manishankar Mondal</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a>
|
<a href=/website/people/C/C-Roy/>C. Roy</a>
|
<a href=/website/people/K/Kevin-A-Schneider/>Kevin A. Schneider</a><br><a href=/website/volumes/G20-1/ class=text-muted>Global Water Futures 2020</a></span></p><div class="card bg-light mb-2 mb-lg-3 collapse abstract-collapse" id=abstract-G20-1138><div class="card-body p-3 small">Evolutionary coupling is a well investigated phenomenon during software evolution and maintenance. If two or more program entities co-change (i.e., change together) frequently during evolution, it is expected that the entities are coupled. This type of coupling is called evolutionary coupling or change coupling in the literature. Evolutionary coupling is realized using association rules and two measures: support and confidence. Association rules have been extensively used for predicting co-change candidates for a target program entity (i.e., an entity that a programmer attempts to change). However, association rules often predict a large number of co-change candidates with many false positives. Thus, it is important to rank the predicted co-change candidates so that the true positives get higher priorities. The predicted co-change candidates have always been ranked using the support and confidence measures of the association rules. In our research, we investigate five different ranking mechanisms on thousands of commits of ten diverse subject systems. On the basis of our findings, we propose a history-based ranking approach, HistoRank (History-based Ranking), that analyzes the previous ranking history to dynamically select the most appropriate one from those five ranking mechanisms for ranking co-change candidates of a target program entity. According to our experiment result, HistoRank outperforms each individual ranking mechanism with a significantly better MAP (mean average precision). We investigate different variants of HistoRank and realize that the variant that emphasizes the ranking in the most recent occurrence of co-change in the history performs the best.</div></div><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2020.GWF-1.139.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G20-1139.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib
</a><a class="badge badge-info align-middle mr-1" href=#abstract-G20-1139 data-toggle=collapse aria-expanded=false aria-controls=abstract-G20-1139 title="Show Abstract">abs</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G20-1139/>Investigating Near-Miss Micro-Clones in Evolving Software</a></strong><br><a href=/website/people/M/Manishankar-Mondal/>Manishankar Mondal</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a>
|
<a href=/website/people/C/C-Roy/>C. Roy</a>
|
<a href=/website/people/K/Kevin-A-Schneider/>Kevin A. Schneider</a><br><a href=/website/volumes/G20-1/ class=text-muted>Global Water Futures 2020</a></span></p><div class="card bg-light mb-2 mb-lg-3 collapse abstract-collapse" id=abstract-G20-1139><div class="card-body p-3 small">Code clones are the same or nearly similar code fragments in a software system's code-base. While the existing studies have extensively studied regular code clones in software systems, micro-clones have been mostly ignored. Although an existing study investigated consistent changes in exact micro-clones, near-miss micro-clones have never been investigated. In our study, we investigate the importance of near-miss micro-clones in software evolution and maintenance by automatically detecting and analyzing the consistent updates that they experienced during the whole period of evolution of our subject systems. We compare the consistent co-change tendency of near-miss micro-clones with that of exact micro-clones and regular code clones. According to our investigation on thousands of revisions of six open-source subject systems written in two different programming languages, near-miss micro-clones have a significantly higher tendency of experiencing consistent updates compared to exact micro-clones and regular (both exact and near-miss) code clones. Consistent updates in near-miss micro-clones have a high tendency of being related with bug-fixes. Moreover, the percentage of commit operations where near-miss micro-clones experience consistent updates is considerably higher than that of regular clones and exact micro-clones. We finally observe that near-miss micro-clones staying in close proximity to each other have a high tendency of experiencing consistent updates. Our research implies that near-miss micro-clones should be considered equally important as of regular clones and exact micro-clones when making clone management decisions.</div></div><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2020.GWF-1.145.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G20-1145.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G20-1145/>A universal cross language software similarity detector for open source software categorization</a></strong><br><a href=/website/people/K/Kawser-Wazed-Nafi/>Kawser Wazed Nafi</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a>
|
<a href=/website/people/C/C-Roy/>C. Roy</a>
|
<a href=/website/people/K/Kevin-A-Schneider/>Kevin A. Schneider</a><br><a href=/website/volumes/G20-1/ class=text-muted>Global Water Futures 2020</a></span></p><h4>2019</h4><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2019.GWF-1.134.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G19-1134.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib
</a><a class="badge badge-info align-middle mr-1" href=#abstract-G19-1134 data-toggle=collapse aria-expanded=false aria-controls=abstract-G19-1134 title="Show Abstract">abs</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G19-1134/>Automatic Components Separation of Obfuscated Android Applications: An Empirical Study of Design Based Features</a></strong><br><a href=/website/people/A/A-Mondal/>A. Mondal</a>
|
<a href=/website/people/C/C-Roy/>C. Roy</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a>
|
<a href=/website/people/K/Kevin-A-Schneider/>Kevin A. Schneider</a><br><a href=/website/volumes/G19-1/ class=text-muted>Global Water Futures 2019</a></span></p><div class="card bg-light mb-2 mb-lg-3 collapse abstract-collapse" id=abstract-G19-1134><div class="card-body p-3 small">In modern days, mobile applications (apps) have become omnipresent. Components of mobile apps (such as 3rd party libraries) require to be separated and analyzed differently for security issue detection, repackaged app detection, tumor code purification and so on. Various techniques are available to automatically analyze mobile apps. However, analysis of the app's executable binary remains challenging due to required curated database, large codebases and obfuscation. Considering these, we focus on exploring a versatile technique to separate different components with design-based features independent of code obfuscation. Particularly, we conducted an empirical study using design patterns and fuzzy signatures to separate app components such as 3rd party libraries. In doing so, we built a system for automatically extracting design patterns from both the executable package (APK) and Jar of an Android application. The experimental results with various standard datasets containing 3rd party libraries, obfuscated apps and malwares reveal that design features like these are present significantly within them (within 60% APKs including malware). Moreover, these features remain unaltered even after app obfuscation. Finally, as a case study, we found that the design patterns alone can detect 3rd party libraries within the obfuscated apps considerably (F1 score is 32%). Overall, our empirical study reveals that design features might play a versatile role in separating various Android components for various purposes.</div></div><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2019.GWF-1.136.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G19-1136.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G19-1136/>An empirical study on bug propagation through code cloning</a></strong><br><a href=/website/people/M/Manishankar-Mondal/>Manishankar Mondal</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a>
|
<a href=/website/people/C/C-Roy/>C. Roy</a>
|
<a href=/website/people/K/Kevin-A-Schneider/>Kevin A. Schneider</a><br><a href=/website/volumes/G19-1/ class=text-muted>Global Water Futures 2019</a></span></p><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2019.GWF-1.137.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G19-1137.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib
</a><a class="badge badge-info align-middle mr-1" href=#abstract-G19-1137 data-toggle=collapse aria-expanded=false aria-controls=abstract-G19-1137 title="Show Abstract">abs</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G19-1137/>Investigating Context Adaptation Bugs in Code Clones</a></strong><br><a href=/website/people/M/Manishankar-Mondal/>Manishankar Mondal</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a>
|
<a href=/website/people/C/C-Roy/>C. Roy</a>
|
<a href=/website/people/K/Kevin-A-Schneider/>Kevin A. Schneider</a><br><a href=/website/volumes/G19-1/ class=text-muted>Global Water Futures 2019</a></span></p><div class="card bg-light mb-2 mb-lg-3 collapse abstract-collapse" id=abstract-G19-1137><div class="card-body p-3 small">The identical or nearly similar code fragments in a code-base are called code clones. There is a common belief that code cloning (copy/pasting code fragments) can introduce bugs in a software system if the copied code fragments are not properly adapted to their contexts (i.e., surrounding code). However, none of the existing studies have investigated whether such bugs are really present in code clones. We denote these bugs as Context Adaptation Bugs, or simply Context-Bugs, in our paper and investigate the extent to which they can be present in code clones. We define and automatically analyze two clone evolutionary patterns that indicate fixing of Context-Bugs. According to our analysis on thousands of revisions of six open-source subject systems written in Java, C, and C#, code cloning often introduces Context-Bugs in software systems. Around 50% of the clone related bug-fixes can occur for fixing Context-Bugs. Cloning (copy/pasting) a newly created code fragment (i.e., a code fragment that was not added in a former revision) is more likely to introduce Context-Bugs compared to cloning a preexisting fragment (i.e., a code fragment that was added in a former revision). Moreover, cloning across different files appears to have a significantly higher tendency of introducing Context-Bugs compared to cloning within the same file. Finally, Type 3 clones (gapped clones) have the highest tendency of containing Context-Bugs among the three major clone-types. Our findings can be important for early detection as well as removal of Context-Bugs in code clones.</div></div><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2019.GWF-1.140.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G19-1140.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib
</a><a class="badge badge-info align-middle mr-1" href=#abstract-G19-1140 data-toggle=collapse aria-expanded=false aria-controls=abstract-G19-1140 title="Show Abstract">abs</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G19-1140/>Designing for Real-Time Groupware Systems to Support Complex Scientific Data Analysis</a></strong><br><a href=/website/people/G/Golam-Mostaeen/>Golam Mostaeen</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a>
|
<a href=/website/people/C/C-Roy/>C. Roy</a>
|
<a href=/website/people/K/Kevin-A-Schneider/>Kevin A. Schneider</a><br><a href=/website/volumes/G19-1/ class=text-muted>Global Water Futures 2019</a></span></p><div class="card bg-light mb-2 mb-lg-3 collapse abstract-collapse" id=abstract-G19-1140><div class="card-body p-3 small">Scientific Workflow Management Systems (SWfMSs) have become popular for accelerating the specification, execution, visualization, and monitoring of data-intensive scientific experiments. Unfortunately, to the best of our knowledge no existing SWfMSs directly support collaboration. Data is increasing in complexity, dimensionality, and volume, and the efficient analysis of data often goes beyond the realm of an individual and requires collaboration with multiple researchers from varying domains. In this paper, we propose a groupware system architecture for data analysis that in addition to supporting collaboration, also incorporates features from SWfMSs to support modern data analysis processes. As a proof of concept for the proposed architecture we developed SciWorCS - a groupware system for scientific data analysis. We present two real-world use-cases: collaborative software repository analysis and bioinformatics data analysis. The results of the experiments evaluating the proposed system are promising. Our bioinformatics user study demonstrates that SciWorCS can leverage real-world data analysis tasks by supporting real-time collaboration among users.</div></div><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2019.GWF-1.141.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G19-1141.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib
</a><a class="badge badge-info align-middle mr-1" href=#abstract-G19-1141 data-toggle=collapse aria-expanded=false aria-controls=abstract-G19-1141 title="Show Abstract">abs</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G19-1141/>CloneCognition: machine learning based code clone validation tool</a></strong><br><a href=/website/people/G/Golam-Mostaeen/>Golam Mostaeen</a>
|
<a href=/website/people/J/Jeffrey-Svajlenko/>Jeffrey Svajlenko</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a>
|
<a href=/website/people/C/C-Roy/>C. Roy</a>
|
<a href=/website/people/K/Kevin-A-Schneider/>Kevin A. Schneider</a><br><a href=/website/volumes/G19-1/ class=text-muted>Global Water Futures 2019</a></span></p><div class="card bg-light mb-2 mb-lg-3 collapse abstract-collapse" id=abstract-G19-1141><div class="card-body p-3 small">A code clone is a pair of similar code fragments, within or between software systems. To detect each possible clone pair from a software system while handling the complex code structures, the clone detection tools undergo a lot of generalization of the original source codes. The generalization often results in returning code fragments that are only coincidentally similar and not considered clones by users, and hence requires manual validation of the reported possible clones by users which is often both time-consuming and challenging. In this paper, we propose a machine learning based tool 'CloneCognition' (Open Source Codes: https://github.com/pseudoPixels/CloneCognition ; Video Demonstration: https://www.youtube.com/watch?v=KYQjmdr8rsw) to automate the laborious manual validation process. The tool runs on top of any code clone detection tools to facilitate the clone validation process. The tool shows promising clone classification performance with an accuracy of up to 87.4%. The tool also exhibits significant improvement in the results when compared with state-of-the-art techniques for code clone validation.</div></div><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2019.GWF-1.142.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G19-1142.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib
</a><a class="badge badge-info align-middle mr-1" href=#abstract-G19-1142 data-toggle=collapse aria-expanded=false aria-controls=abstract-G19-1142 title="Show Abstract">abs</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G19-1142/>CLCDSA: Cross Language Code Clone Detection using Syntactical Features and API Documentation</a></strong><br><a href=/website/people/K/Kawser-Wazed-Nafi/>Kawser Wazed Nafi</a>
|
<a href=/website/people/T/Tonny-Shekha-Kar/>Tonny Shekha Kar</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a>
|
<a href=/website/people/C/C-Roy/>C. Roy</a>
|
<a href=/website/people/K/Kevin-A-Schneider/>Kevin A. Schneider</a><br><a href=/website/volumes/G19-1/ class=text-muted>Global Water Futures 2019</a></span></p><div class="card bg-light mb-2 mb-lg-3 collapse abstract-collapse" id=abstract-G19-1142><div class="card-body p-3 small">Software clones are detrimental to software maintenance and evolution and as a result many clone detectors have been proposed. These tools target clone detection in software applications written in a single programming language. However, a software application may be written in different languages for different platforms to improve the application's platform compatibility and adoption by users of different platforms. Cross language clones (CLCs) introduce additional challenges when maintaining multi-platform applications and would likely go undetected using existing tools. In this paper, we propose CLCDSA, a cross language clone detector which can detect CLCs without extensive processing of the source code and without the need to generate an intermediate representation. The proposed CLCDSA model analyzes different syntactic features of source code across different programming languages to detect CLCs. To support large scale clone detection, the CLCDSA model uses an action filter based on cross language API call similarity to discard non-potential clones. The design methodology of CLCDSA is two-fold: (a) it detects CLCs on the fly by comparing the similarity of features, and (b) it uses a deep neural network based feature vector learning model to learn the features and detect CLCs. Early evaluation of the model observed an average precision, recall and F-measure score of 0.55, 0.86, and 0.64 respectively for the first phase and 0.61, 0.93, and 0.71 respectively for the second phase which indicates that CLCDSA outperforms all available models in detecting cross language clones.</div></div><h4>2018</h4><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2018.GWF-1.30.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G18-1030.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib
</a><a class="badge badge-info align-middle mr-1" href=#abstract-G18-1030 data-toggle=collapse aria-expanded=false aria-controls=abstract-G18-1030 title="Show Abstract">abs</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G18-1030/>Optimized Storing of Workflow Outputs through Mining Association Rules</a></strong><br><a href=/website/people/D/Debasish-Chakroborti/>Debasish Chakroborti</a>
|
<a href=/website/people/M/Manishankar-Mondal/>Manishankar Mondal</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a>
|
<a href=/website/people/C/C-Roy/>C. Roy</a>
|
<a href=/website/people/K/Kevin-A-Schneider/>Kevin A. Schneider</a><br><a href=/website/volumes/G18-1/ class=text-muted>Global Water Futures 2018</a></span></p><div class="card bg-light mb-2 mb-lg-3 collapse abstract-collapse" id=abstract-G18-1030><div class="card-body p-3 small">Workflows are frequently built and used to systematically process large datasets using workflow management systems (WMS). A workflow (i.e., a pipeline) is a finite set of processing modules organized as a series of steps that is applied to an input dataset to produce a desired output. In a workflow management system, users generally create workflows manually for their own investigations. However, workflows can sometimes be lengthy and the constituent processing modules might often be computationally expensive. In this situation, it would be beneficial if users could reuse intermediate stage results generated by previously executed workflows for executing their current workflow.In this paper, we propose a novel technique based on association rule mining for suggesting which intermediate stage results from a workflow that a user is going to execute should be stored for reusing in the future. We call our proposed technique, RISP (Recommending Intermediate States from Pipelines). According to our investigation on hundreds of workflows from two scientific workflow management systems, our proposed technique can efficiently suggest intermediate state results to store for future reuse. The results that are suggested to be stored have a high reuse frequency. Moreover, for creating around 51% of the entire pipelines, we can reuse results suggested by our technique. Finally, we can achieve a considerable gain (74% gain) in execution time by reusing intermediate results stored by the suggestions provided by our proposed technique. We believe that our technique (RISP) has the potential to have a significant positive impact on Big-Data systems, because it can considerably reduce execution time of the workflows through appropriate reuse of intermediate state results, and hence, can improve the performance of the systems.</div></div><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2018.GWF-1.62.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G18-1062.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib
</a><a class="badge badge-info align-middle mr-1" href=#abstract-G18-1062 data-toggle=collapse aria-expanded=false aria-controls=abstract-G18-1062 title="Show Abstract">abs</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G18-1062/>[Research Paper] Detecting Evolutionary Coupling Using Transitive Association Rules</a></strong><br><a href=/website/people/M/Md-Anaytul-Islam/>Md. Anaytul Islam</a>
|
<a href=/website/people/M/Md-Moksedul-Islam/>Md. Moksedul Islam</a>
|
<a href=/website/people/M/Manishankar-Mondal/>Manishankar Mondal</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a>
|
<a href=/website/people/C/C-Roy/>C. Roy</a>
|
<a href=/website/people/K/Kevin-A-Schneider/>Kevin A. Schneider</a><br><a href=/website/volumes/G18-1/ class=text-muted>Global Water Futures 2018</a></span></p><div class="card bg-light mb-2 mb-lg-3 collapse abstract-collapse" id=abstract-G18-1062><div class="card-body p-3 small">If two or more program entities (such as files, classes, methods) co-change (i.e., change together) frequently during software evolution, then it is likely that these two entities are coupled (i.e., the entities are related). Such a coupling is termed as evolutionary coupling in the literature. The concept of traditional evolutionary coupling restricts us to assume coupling among only those entities that changed together in the past. The entities that did not co-change in the past might also have coupling. However, such couplings can not be retrieved using the current concept of detecting evolutionary coupling in the literature. In this paper, we investigate whether we can detect such couplings by applying transitive rules on the evolutionary couplings detected using the traditional mechanism. We call these couplings that we detect using our proposed mechanism as transitive evolutionary couplings. According to our research on thousands of revisions of four subject systems, transitive evolutionary couplings combined with the traditional ones provide us with 13.96% higher recall and 5.56% higher precision in detecting future co-change candidates when compared with a state-of-the-art technique.</div></div><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2018.GWF-1.100.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G18-1100.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib
</a><a class="badge badge-info align-middle mr-1" href=#abstract-G18-1100 data-toggle=collapse aria-expanded=false aria-controls=abstract-G18-1100 title="Show Abstract">abs</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G18-1100/>Fine-Grained Attribute Level Locking Scheme for Collaborative Scientific Workflow Development</a></strong><br><a href=/website/people/G/Golam-Mostaeen/>Golam Mostaeen</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a>
|
<a href=/website/people/C/C-Roy/>C. Roy</a>
|
<a href=/website/people/K/Kevin-A-Schneider/>Kevin A. Schneider</a><br><a href=/website/volumes/G18-1/ class=text-muted>Global Water Futures 2018</a></span></p><div class="card bg-light mb-2 mb-lg-3 collapse abstract-collapse" id=abstract-G18-1100><div class="card-body p-3 small">Scientific Workflow Management Systems are being widely used in recent years for data-intensive analysis tasks or domain-specific discoveries. It often becomes challenging for an individual to effectively analyze the large scale scientific data of relatively higher complexity and dimensions, and requires a collaboration of multiple members of different disciplines. Hence, researchers have focused on designing collaborative workflow management systems. However, consistency management in the face of conflicting concurrent operations of the collaborators is a major challenge in such systems. In this paper, we propose a locking scheme (e.g., collaborator gets write access to non-conflicting components of the workflow at a given time) to facilitate consistency management in collaborative scientific workflow management systems. The proposed method allows locking workflow components at a granular level in addition to supporting locks on a targeted part of the collaborative workflow. We conducted several experiments to analyze the performance of the proposed method in comparison to related existing methods. Our studies show that the proposed method can reduce the average waiting time of a collaborator by up to 36.19% in comparison to existing descendent modular level locking techniques for collaborative scientific workflow management systems.</div></div><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2018.GWF-1.101.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G18-1101.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib
</a><a class="badge badge-info align-middle mr-1" href=#abstract-G18-1101 data-toggle=collapse aria-expanded=false aria-controls=abstract-G18-1101 title="Show Abstract">abs</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G18-1101/>[Research Paper] On the Use of Machine Learning Techniques Towards the Design of Cloud Based Automatic Code Clone Validation Tools</a></strong><br><a href=/website/people/G/Golam-Mostaeen/>Golam Mostaeen</a>
|
<a href=/website/people/J/Jeffrey-Svajlenko/>Jeffrey Svajlenko</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a>
|
<a href=/website/people/C/C-Roy/>C. Roy</a>
|
<a href=/website/people/K/Kevin-A-Schneider/>Kevin A. Schneider</a><br><a href=/website/volumes/G18-1/ class=text-muted>Global Water Futures 2018</a></span></p><div class="card bg-light mb-2 mb-lg-3 collapse abstract-collapse" id=abstract-G18-1101><div class="card-body p-3 small">A code clone is a pair of code fragments, within or between software systems that are similar. Since code clones often negatively impact the maintainability of a software system, a great many numbers of code clone detection techniques and tools have been proposed and studied over the last decade. To detect all possible similar source code patterns in general, the clone detection tools work on syntax level (such as texts, tokens, AST and so on) while lacking user-specific preferences. This often means the reported clones must be manually validated prior to any analysis in order to filter out the true positive clones from task or user-specific considerations. This manual clone validation effort is very time-consuming and often error-prone, in particular for large-scale clone detection. In this paper, we propose a machine learning based approach for automating the validation process. In an experiment with clones detected by several clone detectors in several different software systems, we found our approach has an accuracy of up to 87.4% when compared against the manual validation by multiple expert judges. The proposed method shows promising results in several comparative studies with the existing related approaches for automatic code clone validation. We also present our experimental results in terms of different code clone detection tools, machine learning algorithms and open source software systems.</div></div><p class="d-sm-flex align-items-stretch"><span class="d-block mr-2 text-nowrap list-button-row"><a class="badge badge-primary align-middle mr-1" href=https://mobehbooei.github.io/website/2018.GWF-1.102.pdf data-toggle=tooltip data-placement=top title="Open PDF">pdf
</a><a class="badge badge-secondary align-middle mr-1" href=/website/G18-1102.bib data-toggle=tooltip data-placement=top title="Export to BibTeX">bib
</a><a class="badge badge-info align-middle mr-1" href=#abstract-G18-1102 data-toggle=collapse aria-expanded=false aria-controls=abstract-G18-1102 title="Show Abstract">abs</a><br class="d-none d-sm-inline-block"></span><span class=d-block><strong><a class=align-middle href=/website/G18-1102/>[Research Paper] CroLSim: Cross Language Software Similarity Detector Using API Documentation</a></strong><br><a href=/website/people/K/Kawser-Wazed-Nafi/>Kawser Wazed Nafi</a>
|
<a href=/website/people/B/B-Roy/>B. Roy</a>
|
<a href=/website/people/C/C-Roy/>C. Roy</a>
|
<a href=/website/people/K/Kevin-A-Schneider/>Kevin A. Schneider</a><br><a href=/website/volumes/G18-1/ class=text-muted>Global Water Futures 2018</a></span></p><div class="card bg-light mb-2 mb-lg-3 collapse abstract-collapse" id=abstract-G18-1102><div class="card-body p-3 small">In today's open source era, developers look forsimilar software applications in source code repositories for anumber of reasons, including, exploring alternative implementations, reusing source code, or looking for a better application. However, while there are a great many studies for finding similarapplications written in the same programming language, there isa marked lack of studies for finding similar software applicationswritten in different languages. In this paper, we fill the gapby proposing a novel modelCroLSimwhich is able to detectsimilar software applications across different programming lan-guages. In our approach, we use the API documentation tofind relationships among the API calls used by the differentprogramming languages. We adopt a deep learning based word-vector learning method to identify semantic relationships amongthe API documentation which we then use to detect cross-language similar software applications. For evaluating CroLSim, we formed a repository consisting of 8,956 Java, 7,658 C#, and 10,232 Python applications collected from GitHub. Weobserved thatCroLSimcan successfully detect similar softwareapplications across different programming languages with a meanaverage precision rate of 0.65, an average confidence rate of3.6 (out of 5) with 75% high rated successful queries, whichoutperforms all related existing approaches with a significantperformance improvement.</div></div></div><div class=col-lg-3><a class="btn btn-lg btn-secondary btn-block mb-2" href="https://www.semanticscholar.org/search?q=B.+Roy" title="Search for 'B. Roy' on Semantic Scholar"><i class="ai ai-semantic-scholar"></i><span class=pl-sm-2>Search</span></a><div class=row><div class="col-12 col-md-6 col-lg-12"><div class=card><h5 class=card-header>Co-authors</h5><ul class="list-group list-group-flush list-group-compact"><li class=list-group-item><a href=/website/people/K/Kevin-A-Schneider/ class=align-middle>Kevin A. Schneider</a>
<span class="badge badge-secondary align-middle ml-2">26</span></li><li class=list-group-item><a href=/website/people/C/C-Roy/ class=align-middle>C. Roy</a>
<span class="badge badge-secondary align-middle ml-2">23</span></li><li class=list-group-item><a href=/website/people/M/Manishankar-Mondal/ class=align-middle>Manishankar Mondal</a>
<span class="badge badge-secondary align-middle ml-2">10</span></li><li class=list-group-item><a href=/website/people/S/Sristy-Sumana-Nath/ class=align-middle>Sristy Sumana Nath</a>
<span class="badge badge-secondary align-middle ml-2">7</span></li><li class=list-group-item><a href=/website/people/G/Golam-Mostaeen/ class=align-middle>Golam Mostaeen</a>
<span class="badge badge-secondary align-middle ml-2">4</span></li><li class="list-group-item list-group-toggle-btn py-1" data-toggle=collapse data-target=#more-coauthors aria-expanded=false aria-controls=more-coauthors>show all...</li><div class="collapse border-top" id=more-coauthors><li class=list-group-item><a href=/website/people/K/Kawser-Wazed-Nafi/ class=align-middle>Kawser Wazed Nafi</a>
<span class="badge badge-secondary align-middle ml-2">4</span></li><li class=list-group-item><a href=/website/people/D/Debasish-Chakroborti/ class=align-middle>Debasish Chakroborti</a>
<span class="badge badge-secondary align-middle ml-2">3</span></li><li class=list-group-item><a href=/website/people/A/Avijit-Bhattacharjee/ class=align-middle>Avijit Bhattacharjee</a>
<span class="badge badge-secondary align-middle ml-2">3</span></li><li class=list-group-item><a href=/website/people/J/Jeffrey-Svajlenko/ class=align-middle>Jeffrey Svajlenko</a>
<span class="badge badge-secondary align-middle ml-2">2</span></li><li class=list-group-item><a href=/website/people/A/A-Mondal/ class=align-middle>A. Mondal</a>
<span class="badge badge-secondary align-middle ml-2">2</span></li><li class=list-group-item><a href=/website/people/M/Md-Anaytul-Islam/ class=align-middle>Md. Anaytul Islam</a>
<span class="badge badge-secondary align-middle ml-2">1</span></li><li class=list-group-item><a href=/website/people/M/Md-Moksedul-Islam/ class=align-middle>Md. Moksedul Islam</a>
<span class="badge badge-secondary align-middle ml-2">1</span></li><li class=list-group-item><a href=/website/people/T/Tonny-Shekha-Kar/ class=align-middle>Tonny Shekha Kar</a>
<span class="badge badge-secondary align-middle ml-2">1</span></li><li class=list-group-item><a href=/website/people/S/Shurui-Zhou/ class=align-middle>Shurui Zhou</a>
<span class="badge badge-secondary align-middle ml-2">1</span></li><li class=list-group-item><a href=/website/people/M/M-M-Hossain/ class=align-middle>M. M. Hossain</a>
<span class="badge badge-secondary align-middle ml-2">1</span></li><li class=list-group-item><a href=/website/people/H/Hamid-Khodabandehloo/ class=align-middle>Hamid Khodabandehloo</a>
<span class="badge badge-secondary align-middle ml-2">1</span></li><li class=list-group-item><a href=/website/people/A/Amit-Mondal/ class=align-middle>Amit Mondal</a>
<span class="badge badge-secondary align-middle ml-2">1</span></li><li class=list-group-item><a href=/website/people/S/Saikat-Mondal/ class=align-middle>Saikat Mondal</a>
<span class="badge badge-secondary align-middle ml-2">1</span></li><li class=list-group-item><a href=/website/people/A/Amit-Kumar-Mondal/ class=align-middle>Amit Kumar Mondal</a>
<span class="badge badge-secondary align-middle ml-2">1</span></li><li class=list-group-item><a href=/website/people/M/Mostafa-AbediniAla/ class=align-middle>Mostafa AbediniAla</a>
<span class="badge badge-secondary align-middle ml-2">1</span></li><li class=list-group-item><a href=/website/people/S/Shamse-Tasnim-Cynthia/ class=align-middle>Shamse Tasnim Cynthia</a>
<span class="badge badge-secondary align-middle ml-2">1</span></li><li class=list-group-item><a href=/website/people/D/Debajyoti-Mondal/ class=align-middle>Debajyoti Mondal</a>
<span class="badge badge-secondary align-middle ml-2">1</span></li><li class=list-group-item><a href=/website/people/M/M-Asaduzzaman/ class=align-middle>M. Asaduzzaman</a>
<span class="badge badge-secondary align-middle ml-2">1</span></li><li class=list-group-item><a href=/website/people/N/Naz-Zarreen-Zarreen-Oishie/ class=align-middle>Naz Zarreen Zarreen Oishie</a>
<span class="badge badge-secondary align-middle ml-2">1</span></li></div></ul></div></div><div class="col-12 col-md-6 col-lg-12"><div class="card my-2 my-md-0 my-lg-2"><h5 class=card-header>Venues</h5><ul class="list-group list-group-flush list-group-compact"><li class=list-group-item><a href=/website/venues/gwf/ class=align-middle>GWF</a><span class="badge badge-secondary align-middle ml-2">34</span></li></ul></div></div></div></div></div></section></div><footer class="bg-gradient-light py-2 py-xl-3 mt-3 mt-md-4 mt-xl-5"><div class=container><p class="text-muted small px-1"><span class="float-right mt-2 ml-2"><a rel=license href=http://creativecommons.org/licenses/by/4.0/><img alt="Creative Commons License" style=border-width:0 src=https://i.creativecommons.org/l/by/4.0/88x31.png></a></span>
ACL materials are Copyright ©&nbsp;1963&ndash;2022 ACL; other materials are copyrighted by their respective copyright holders. Materials prior to 2016 here are licensed under the <a href=https://creativecommons.org/licenses/by-nc-sa/3.0/>Creative Commons Attribution-NonCommercial-ShareAlike 3.0 International License</a>. Permission is granted to make copies for the purposes of teaching and research. Materials published in or after 2016 are licensed on a <a href=https://creativecommons.org/licenses/by/4.0/>Creative Commons Attribution 4.0 International License</a>.</p><p class="text-muted small px-1">The ACL Anthology is managed and built by the <a href=/website/info/credits/>ACL Anthology team</a> of volunteers.</p><p class="text-muted small px-1"><i>Site last built on 17 November 2022 at 01:58 UTC with <a href=https://github.com/acl-org/acl-anthology/tree/51de55f083dd8e08971d5f9d4a69e24f90b89cf2>commit 51de55f0</a>.</i></p></div></footer><script src=https://code.jquery.com/jquery-3.3.1.slim.min.js integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js integrity=sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut crossorigin=anonymous></script><script src=https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/js/bootstrap.min.js integrity=sha384-B0UglyR+jN6CkvvICOB2joaf5I4l3gm9GU6Hc1og6Ls7i6U/mkkaduKaBhlAXv9k crossorigin=anonymous></script><script>$(function(){$('[data-toggle="tooltip"]').tooltip();if($("#toggle-all-abstracts")){$("#toggle-all-abstracts").click(function(){var target=$("#toggle-all-abstracts");target.attr("disabled",true);if(target.attr("data-toggle-state")=="hide"){$(".abstract-collapse").collapse('show');target.attr("data-toggle-state","show");}else{$(".abstract-collapse").collapse('hide');target.attr("data-toggle-state","hide");}
target.attr("disabled",false);});$("#toggle-all-abstracts").attr("disabled",false);}})</script></body></html>